/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user roles and ownership.
 * It avoids complex data validation in favor of rapid prototyping.
 *
 * Data Structure:
 * The Firestore database is organized with top-level collections for vendors, forum threads, community events,
 * communication channels, agreements, consents, disputes, and logs. Vendors have subcollections for listings,
 * orders, reviews, and refund requests. Forum threads have a subcollection for posts. Communication channels have a
 * subcollection for messages.
 *
 * Key Security Decisions:
 * - Public read access is allowed for top-level collections that represent public data (e.g., vendors, forum threads, community events).
 * - Write access to resources is generally restricted to authorized users (e.g., the owner of a vendor profile).
 * - User listing is disallowed.
 * - Read and write access for subcollections is checked against the top-level document
 * - Data integrity checks are performed only when critical for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to vendor profiles. Only the vendor can modify their own profile.
     * @path /vendors/{vendorId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if request.auth.uid == vendorId
     * @deny (create, update, delete): if request.auth.uid != vendorId
     * @principle Public read, owner-only writes.
     */
    // Allow public list access to vendors collection for development
    match /vendors {
      allow list: if true;
    }
    match /vendors/{vendorId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
      allow update: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
      allow delete: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
    }

    /**
     * @description Allows a vendor to manage their own listings.
     * @path /vendors/{vendorId}/listings/{listingId}
     * @allow (create): if request.auth.uid == vendorId
     * @allow (get, list, update, delete): if resource.data.vendorId == vendorId
     * @deny (create): if request.auth.uid != vendorId
     * @deny (get, list, update, delete): if resource.data.vendorId != vendorId
     * @principle Owner-only access.
     */
    match /vendors/{vendorId}/listings/{listingId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
      allow update: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
      allow delete: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
    }

    /**
     * @description Allows a vendor and buyer to access order.
     * @path /vendors/{vendorId}/orders/{orderId}
     * @allow (get, list): if resource.data.vendorId == vendorId
     * @allow (create): if request.auth.uid != null
     * @allow (update, delete): if isExistingVendor(vendorId) && resource.data.vendorId == vendorId
     * @deny (get, list): if resource.data.vendorId != vendorId
     * @deny (create): if request.auth.uid == null
     * @deny (update, delete): if !isExistingVendor(vendorId) || resource.data.vendorId != vendorId
     * @principle Owner-only access.
     */
     match /vendors/{vendorId}/orders/{orderId} {
        allow get: if isSignedIn() && (resource.data.vendorId == request.auth.uid || resource.data.buyerId == request.auth.uid || isAdmin());
        // Listing all orders under a vendor is restricted to that vendor or admins.
        allow list: if isSignedIn() && (vendorId == request.auth.uid || isAdmin());

        allow create: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
        allow update: if isSignedIn() && (resource.data.vendorId == request.auth.uid || isAdmin());
        allow delete: if isSignedIn() && (resource.data.vendorId == request.auth.uid || isAdmin());
     }

    /**
     * @description Allows public read access to reviews. Only the review author can modify or delete their own review.
     * @path /vendors/{vendorId}/reviews/{reviewId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.residentId
     * @allow (update, delete): if isExistingReviewAuthor(reviewId, request.auth.uid)
     * @deny (create): if request.auth.uid != request.resource.data.residentId
     * @deny (update, delete): if !isExistingReviewAuthor(reviewId, request.auth.uid)
     * @principle Public read, owner-only writes.
     */
    match /vendors/{vendorId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && request.resource.data.residentId == request.auth.uid;
      allow update: if isSignedIn() && (resource.data.residentId == request.auth.uid || isAdmin());
      allow delete: if isSignedIn() && (resource.data.residentId == request.auth.uid || isAdmin());
    }

    /**
     * @description Allows a vendor to manage their own refund requests.
     * @path /vendors/{vendorId}/refund_requests/{requestId}
     * @allow (get, list, create, update, delete): if request.auth.uid == vendorId
     * @deny (get, list, create, update, delete): if request.auth.uid != vendorId
     * @principle Owner-only access.
     */
    match /vendors/{vendorId}/refund_requests/{requestId} {
      allow get: if isSignedIn() &&
                  (request.auth.uid == vendorId ||
                   resource.data.buyerId == request.auth.uid ||
                   isAdmin());
      allow list: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());

      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
      allow delete: if isSignedIn() && (request.auth.uid == vendorId || isAdmin());
    }

    /**
     * @description Allows public read access to forum threads.
     * @path /forumThreads/{threadId}
     * @allow get, list: if true
     * @allow create, update, delete: if false; // TODO: Add authorization
     * @principle Public read, restricted writes.
     */
    // Top-level access control for forum threads collection
    match /forumThreads {
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    match /forumThreads/{threadId} {
      allow get: if true;
      allow list: if true;

      allow create: if false; // TODO: Add authorization logic for creating forum threads.
      allow update: if false; // TODO: Add authorization logic for updating forum threads.
      allow delete: if false; // TODO: Add authorization logic for deleting forum threads.
    }

    /**
     * @description Allows public read access to forum posts within a thread. Only the author can create a post
     * @path /forumThreads/{threadId}/posts/{postId}
     * @allow get, list: if true
     * @allow create: if request.auth.uid == request.resource.data.authorId
     * @allow update, delete: if false; // TODO: Add authorization
     * @principle Public read, owner-only create, restricted updates/deletes.
     */
    match /forumThreads/{threadId}/posts/{postId} {
      allow get: if true;
      allow list: if true;

      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && (resource.data.authorId == request.auth.uid || isAdmin());
      allow delete: if request.auth != null && (resource.data.authorId == request.auth.uid || isAdmin());
    }

    /**
     * @description Allows public read access to community events.
     * @path /communityEvents/{eventId}
     * @allow get, list: if true
     * @allow create, update, delete: if false; // TODO: Add authorization
     * @principle Public read, restricted writes.
     */
    match /communityEvents/{eventId} {
      allow get: if true;
      allow list: if true;

      allow create: if false; // TODO: Add authorization logic for creating community events.
      allow update: if false; // TODO: Add authorization logic for updating community events.
      allow delete: if false; // TODO: Add authorization logic for deleting community events.
    }

    /**
     * @description Allows access to communication channels for the involved buyer and vendor.
     * @path /comm_channels/{channelId}
     * @allow get, list: if request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.vendorId
     * @allow create: if request.auth.uid == request.resource.data.buyerId || request.auth.uid == request.resource.data.vendorId
     * @allow update, delete: if false; // TODO: Add authorization
     * @principle Shared access between buyer and vendor.
     */
    match /comm_channels/{channelId} {
      allow get: if request.auth != null && (resource.data.buyerId == request.auth.uid || resource.data.vendorId == request.auth.uid);
      allow list: if request.auth != null && (resource.data.buyerId == request.auth.uid || resource.data.vendorId == request.auth.uid); // Listing communication channels is allowed for buyer/vendor

      allow create: if request.auth != null && isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.vendorId == request.auth.uid);
      allow update: if false; // TODO: Add authorization logic for updating communication channels.
      allow delete: if false; // TODO: Add authorization logic for deleting communication channels.
    }

    /**
     * @description Allows access to messages within a communication channel for the involved buyer and vendor.
     * @path /comm_channels/{channelId}/messages/{messageId}
     * @allow get, list: if get(/databases/$(database)/documents/comm_channels/$(channelId)).data.buyerId == request.auth.uid || get(/databases/$(database)/documents/comm_channels/$(channelId)).data.vendorId == request.auth.uid
     * @allow create: if request.auth.uid == request.resource.data.senderId
     * @allow update, delete: if false; // TODO: Add authorization
     * @principle Shared access between buyer and vendor.
     */
    match /comm_channels/{channelId}/messages/{messageId} {
        allow get: if request.auth != null && (get(/databases/$(database)/documents/comm_channels/$(channelId)).data.buyerId == request.auth.uid || get(/databases/$(database)/documents/comm_channels/$(channelId)).data.vendorId == request.auth.uid);
        allow list: if request.auth != null && (get(/databases/$(database)/documents/comm_channels/$(channelId)).data.buyerId == request.auth.uid || get(/databases/$(database)/documents/comm_channels/$(channelId)).data.vendorId == request.auth.uid);

        allow create: if request.auth != null && isSignedIn() && request.resource.data.senderId == request.auth.uid;
        allow update: if false; // TODO: Add authorization logic for updating messages.
        allow delete: if false; // TODO: Add authorization logic for deleting messages.
    }

     /**
      * @description Allows public read access to legal agreement documents.
      * @path /agreements/{agreementId}
      * @allow get, list: if true
      * @allow create, update, delete: if false; // TODO: Add authorization
      * @principle Public read, restricted writes.
      */
    match /agreements/{agreementId} {
        allow get: if true;
        allow list: if true;

        allow create: if request.auth != null && request.auth.token.admin == true;
        allow update: if false; // TODO: Add authorization logic for updating agreements.
        allow delete: if false; // TODO: Add authorization logic for deleting agreements.
    }

    /**
     * @description Allows read/write access to user consent records.
     * @path /consents/{consentId}
     * @allow get, list: if false
     * @allow create: if request.auth.uid == request.resource.data.userId
     * @allow update, delete: if false; // TODO: Add authorization
     * @principle Owner-only access.
     */
    match /consents/{consentId} {
        allow get: if isAdmin() || (request.auth != null && resource.data.userId == request.auth.uid);
        // Allow admins to list all consents for audit; users can only list their own via queries.
        allow list: if isAdmin() || (request.auth != null && resource.data.userId == request.auth.uid);

        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Allows access to disputes data.
     * @path /disputes/{disputeId}
     * @allow get, list, create, update, delete: if false; // TODO: Add authorization
     */
    match /disputes/{disputeId} {
        allow get: if false;
        allow list: if false;

        allow create: if false; // TODO: Add authorization logic for creating disputes.
        allow update: if false; // TODO: Add authorization logic for updating disputes.
        allow delete: if false; // TODO: Add authorization logic for deleting disputes.
    }

    /**
     * @description Logs all incoming webhook events for auditing.
     * @path /logs/webhooks/events/{eventId}
     * @allow get, list, create, update, delete: if false; // TODO: Add authorization
     */
    match /logs/webhooks/events/{eventId} {
        allow get: if false;
        allow list: if false;

        allow create: if false; // TODO: Add authorization logic for creating logs.
        allow update: if false; // TODO: Add authorization logic for updating logs.
        allow delete: if false; // TODO: Add authorization logic for deleting logs.
    }

    /**
     * @description Logs all outgoing transactional emails for auditing.
     * @path /logs/emails/sends/{sendId}
     * @allow get, list, create, update, delete: if false; // TODO: Add authorization
     */
    match /logs/emails/sends/{sendId} {
        allow get: if false;
        allow list: if false;

        allow create: if false; // TODO: Add authorization logic for creating logs.
        allow update: if false; // TODO: Add authorization logic for updating logs.
        allow delete: if false; // TODO: Add authorization logic for deleting logs.
    }


    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

  }
}
